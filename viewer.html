<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Bulukumba GeoViewer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css">
  <style>
    html, body { margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', sans-serif; background: #f4f8fb; }
    #map { width: 100%; height: 100%; }

    /* HEADER (tanpa logo) */
    #header {
      position: absolute; top: 10px; left: 10px;
      background: linear-gradient(90deg, rgba(0,60,136,0.95), rgba(0,128,128,0.95));
      color: white; padding: 10px 16px;
      border-radius: 8px; display: flex; align-items: center; gap: 12px;
      z-index: 3000; box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    }
    #header strong { font-size: 18px; display:block; line-height: 1.1; }
    #header .tagline { font-size: 12px; font-style: italic; opacity: 0.95; }

    /* TOP CONTROLS */
    #dropzone {
      position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
      background: rgba(0,128,128,0.92); color: white; padding: 8px 12px;
      border-radius: 6px; z-index: 2500; font-size: 14px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    #actions {
      position: absolute; top: 70px; left: 10px; z-index: 2500;
      display: flex; gap: 8px;
    }
    .btn {
      background: #ffffff; color: #003c88; border: 1px solid #cfe2ff;
      padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 13px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
    }
    .btn:hover { background: #f1f5ff; }

    /* LEGEND */
    #legend {
      position: absolute; bottom: 40px; right: 10px;
      background: rgba(255,255,255,0.98); padding: 10px;
      border-radius: 6px; font-size: 12px; max-width: 260px; z-index: 2500;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    #legend h4 { margin: 0 0 6px 0; font-size: 12px; }
    #legend div { margin-bottom: 4px; display: flex; align-items: center; }
    #legend .color-box {
      display: inline-block; width: 16px; height: 16px; margin-right: 6px;
      border: 1px solid #555; border-radius: 2px;
    }

    /* PROGRESS BAR */
    #progress-container {
      position: absolute; top: 110px; left: 50%; transform: translateX(-50%);
      width: 320px; background: rgba(255,255,255,0.98);
      border-radius: 6px; padding: 8px; z-index: 2600;
      display: none; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    #progress-bar {
      width: 0%; height: 12px; background: linear-gradient(90deg, #007BFF, #00b3b3);
      border-radius: 4px; transition: width 0.2s;
    }
    #progress-text { font-size: 12px; text-align: center; margin-top: 6px; color: #333; }

    /* WATERMARK (tanpa logo) */
    #watermark {
      position: absolute; bottom: 8px; left: 10px;
      display: flex; align-items: center; gap: 8px;
      font-size: 11px; color: rgba(0,0,0,0.75);
      background: rgba(255,255,255,0.8); padding: 4px 8px;
      border-radius: 6px; z-index: 2500; box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    #watermark .motto { font-weight: 600; color: #003c88; }

    /* NOTIFICATIONS */
    #notifications {
      position: absolute; top: 160px; right: 10px;
      max-width: 380px; z-index: 2700;
      display: flex; flex-direction: column; gap: 8px;
    }
    .note {
      background: #fff; border-left: 4px solid #007BFF;
      padding: 8px 10px; border-radius: 4px; font-size: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15); color: #222;
    }
    .note.error { border-color: #dc3545; }
    .note.success { border-color: #28a745; }
    .note .title { font-weight: 700; margin-bottom: 4px; }
    .note .body { white-space: pre-wrap; }
    .note button { margin-top: 6px; font-size: 11px; background: transparent; border: none; color: #007BFF; cursor: pointer; }

    /* POPUP EDIT ATTRIBUTES */
    #popup {
      position: absolute; background: #fff; padding: 10px; min-width: 240px;
      border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 3000; display: none;
    }
    #popup h4 { margin: 0 0 8px 0; font-size: 13px; color: #003c88; }
    #popup form { max-height: 260px; overflow: auto; }
    #popup label { display: block; font-size: 12px; margin: 6px 0 2px; }
    #popup input { width: 100%; padding: 6px; font-size: 12px; border: 1px solid #ccd; border-radius: 4px; }
    #popup .field-missing input { border-color: #dc3545; background: #fff5f5; }
    #popup .row-actions { margin-top: 8px; display: flex; gap: 8px; justify-content: flex-end; }
    #popup .btn { padding: 6px 10px; }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <strong>Bulukumba GeoViewer</strong>
      <div class="tagline">Bumi Panrita Lopi – Data untuk Semua</div>
    </div>
  </div>

  <div id="dropzone">Tarik & letakkan file GeoJSON / SHP / ZIP / PRJ dan/atau SLD di sini</div>
  <div id="actions">
    <button id="export-all" class="btn">Export GeoJSON</button>
    <button id="export-selected" class="btn">Export GeoJSON (terpilih)</button>
  </div>

  <div id="map"></div>
  <div id="legend"></div>

  <!-- Progress bar -->
  <div id="progress-container">
    <div id="progress-bar"></div>
    <div id="progress-text">0%</div>
  </div>

  <!-- Watermark -->
  <div id="watermark">
    <span class="motto">Bulukumba</span> • Design by <strong>callunk76</strong>
  </div>

  <!-- Notifications -->
  <div id="notifications"></div>

  <!-- Popup edit -->
  <div id="popup"></div>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ol-sld@latest/dist/ol-sld.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/shpjs@latest/dist/shp.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/proj4@latest/dist/proj4.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epsg-index@latest/epsg-index.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epsg-index@latest/epsg-index-all.js"></script>

  <script>
    let geojsonData = null;
    let sldText = null;
    let vectorLayer = null;
    let detectedProjection = 'EPSG:4326';

    const map = new ol.Map({
      target: 'map',
      layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ],
      view: new ol.View({ center: ol.proj.fromLonLat([120, -5.5]), zoom: 10 })
    });

    // Interactions
    const selectInteraction = new ol.interaction.Select();
    map.addInteraction(selectInteraction);

    // ===== Utilities =====
    function rgbaToCss(color) {
      if (Array.isArray(color)) return `rgba(${color.join(',')})`;
      return color || '#ccc';
    }
    function showProgress() {
      document.getElementById('progress-container').style.display = 'block';
      updateProgress(0);
    }
    function updateProgress(percent) {
      document.getElementById('progress-bar').style.width = percent + '%';
      document.getElementById('progress-text').textContent = percent + '%';
    }
    function hideProgress() {
      document.getElementById('progress-container').style.display = 'none';
    }
    function pushNote({title, body, type='info'}) {
      const wrap = document.getElementById('notifications');
      const div = document.createElement('div');
      div.className = 'note ' + (type === 'error' ? 'error' : type === 'success' ? 'success' : '');
      const t = document.createElement('div'); t.className = 'title'; t.textContent = title;
      const b = document.createElement('div'); b.className = 'body'; b.textContent = body;
      const btn = document.createElement('button'); btn.textContent = 'Tutup';
      btn.onclick = () => wrap.removeChild(div);
      div.appendChild(t); div.appendChild(b); div.appendChild(btn);
      wrap.appendChild(div);
    }
    function download(filename, text) {
      const blob = new Blob([text], {type: 'application/json;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }

    // PRJ -> EPSG
    function detectEPSGFromPRJ(prjText) {
      try {
        const match = prjText.match(/AUTHORITY\["EPSG","(\d+)"\]/);
        if (match) {
          const epsgCode = `EPSG:${match[1]}`;
          if (epsgIndex[epsgCode]) {
            proj4.defs(epsgCode, epsgIndex[epsgCode].proj4);
            ol.proj.proj4.register(proj4);
            detectedProjection = epsgCode;
            pushNote({ title: 'Proyeksi terdeteksi', body: `Menggunakan ${epsgCode} dari PRJ.`, type: 'success' });
          } else {
            pushNote({ title: 'EPSG tidak dikenali', body: `Kode ${epsgCode} tidak ada di indeks. Pakai EPSG:4326.`, type: 'error' });
          }
        } else {
          pushNote({ title: 'PRJ tidak memuat AUTHORITY EPSG', body: 'Tidak ditemukan AUTHORITY["EPSG","xxxx"]. Gunakan EPSG:4326.', type: 'error' });
        }
      } catch (err) {
        pushNote({ title: 'Gagal baca PRJ', body: String(err), type: 'error' });
      }
    }

    // Validasi field yang direferensikan SLD
    function validateAttributesAgainstSLD(geojson, sldObject) {
      try {
        const sample = (geojson.features && geojson.features[0]) ? geojson.features[0].properties : null;
        if (!sample) {
          pushNote({ title: 'GeoJSON tanpa fitur', body: 'Tidak ada fitur untuk diuji terhadap SLD.', type: 'error' });
          return [];
        }
        const namedLayer = Object.values(sldObject.namedLayers || {})[0];
        const userStyles = (namedLayer && namedLayer.userStyles) || [];
        const requiredFields = new Set();

        userStyles.forEach(us => {
          (us.rules || []).forEach(rule => {
            if (rule && rule.filter && rule.filter.type === 'comparison' && rule.filter.property) {
              requiredFields.add(rule.filter.property);
            }
            (rule.symbolizers || []).forEach(sym => {
              if (sym.kind === 'Text' && sym.label && sym.label.type === 'property') {
                requiredFields.add(sym.label.property);
              }
            });
          });
        });

        const missing = [];
        requiredFields.forEach(f => { if (!(f in sample)) missing.push(f); });
        if (missing.length) {
          pushNote({
            title: 'Atribut SLD tidak ditemukan',
            body: `Field hilang: ${missing.join(', ')}.\nCocokkan nama field di data atau sesuaikan SLD.`,
            type: 'error'
          });
        } else {
          pushNote({ title: 'Validasi atribut', body: 'Semua field SLD ada di data.', type: 'success' });
        }
        return missing;
      } catch (err) {
        pushNote({ title: 'Gagal validasi SLD vs data', body: String(err), type: 'error' });
        return [];
      }
    }

    function buildLegendFromSLD(sldObject) {
      const legendDiv = document.getElementById('legend');
      legendDiv.innerHTML = '<h4>Legenda</h4>';
      const namedLayer = Object.values(sldObject.namedLayers || {})[0];
      const userStyles = (namedLayer && namedLayer.userStyles) || [];

      userStyles.forEach(style => {
        (style.rules || []).forEach(rule => {
          let color = '#ccc';
          if (rule.symbolizers && rule.symbolizers.length > 0) {
            const sym = rule.symbolizers[0];
            if (sym.kind === 'Polygon' || sym.kind === 'Fill') {
              if (sym.color) color = rgbaToCss(sym.color);
              if (sym.strokeColor) color = rgbaToCss(sym.strokeColor);
            }
            if (sym.kind === 'Line' || sym.kind === 'Stroke') {
              if (sym.color) color = rgbaToCss(sym.color);
            }
            if (sym.kind === 'Mark' || sym.kind === 'Icon') {
              if (sym.color) color = rgbaToCss(sym.color);
            }
          }
          const label = rule.title || rule.name || 'Tanpa label';
          const item = document.createElement('div');
          const colorBox = document.createElement('span');
          colorBox.className = 'color-box';
          colorBox.style.background = color;
          const text = document.createElement('span');
          text.textContent = label;
          item.appendChild(colorBox);
          item.appendChild(text);
          legendDiv.appendChild(item);
        });
      });
    }

    function clearLegend() {
      document.getElementById('legend').innerHTML = '';
    }

    function defaultStyle() {
      return new ol.style.Style({
        stroke: new ol.style.Stroke({ color: '#007BFF', width: 2 }),
        fill: new ol.style.Fill({ color: 'rgba(0,123,255,0.2)' }),
        image: new ol.style.Circle({
          radius: 5,
          fill: new ol.style.Fill({ color: '#FF4136' }),
          stroke: new ol.style.Stroke({ color: 'white', width: 1 })
        })
      });
    }

    function renderLayer() {
      if (!geojsonData) return;

      // Guard untuk error "SLDReader is not defined"
      if (sldText && (typeof SLDReader === 'undefined')) {
        pushNote({
          title: 'SLD tidak valid',
          body: 'SLDReader tidak tersedia. Pastikan script ol-sld sudah termuat dan tidak diblokir. Style default dipakai.',
          type: 'error'
        });
      }

      let styleFunction = defaultStyle();

      if (sldText && typeof SLDReader !== 'undefined') {
        try {
          const sldObject = SLDReader.Reader(sldText);
          const layerNames = Object.keys(sldObject.namedLayers || {});
          if (!layerNames.length) {
            pushNote({ title: 'SLD tanpa NamedLayer', body: 'Gunakan <NamedLayer> pada SLD.', type: 'error' });
          } else {
            const style = SLDReader.getStyle(sldObject, layerNames[0]);
            pushNote({ title: 'SLD diterapkan', body: `NamedLayer: ${layerNames[0]}`, type: 'success' });

            const missing = validateAttributesAgainstSLD(geojsonData, sldObject);

            // Terapkan style dari SLD
            styleFunction = feature => SLDReader.olStyle(style, feature);

            // Legend
            buildLegendFromSLD(sldObject);

            // Simpan info missing fields untuk highlight popup
            window._missingFieldsForPopup = new Set(missing);
          }
        } catch (err) {
          pushNote({ title: 'Gagal parse SLD', body: String(err), type: 'error' });
          clearLegend();
        }
      } else {
        clearLegend();
      }

      if (vectorLayer) map.removeLayer(vectorLayer);

      const features = new ol.format.GeoJSON().readFeatures(geojsonData, {
        dataProjection: detectedProjection,
        featureProjection: 'EPSG:3857'
      });

      // Normalisasi tipe untuk kesesuaian SLD contoh Anda (remark 1..6 sebagai string)
      features.forEach(f => {
        const props = f.getProperties();
        if (props && props.remark !== undefined && typeof props.remark !== 'string') {
          f.set('remark', String(props.remark));
        }
        if (props && props.wadmkd !== undefined && props.wadmkd !== null) {
          f.set('wadmkd', String(props.wadmkd));
        }
      });

      vectorLayer = new ol.layer.Vector({
        source: new ol.source.Vector({ features }),
        style: styleFunction
      });

      map.addLayer(vectorLayer);

      try {
        const extent = vectorLayer.getSource().getExtent();
        if (extent && extent.every(Number.isFinite)) {
          map.getView().fit(extent, { padding: [20,20,20,20], maxZoom: 15 });
        }
      } catch (e) {
        pushNote({ title: 'Gagal fit extent', body: String(e), type: 'error' });
      }

      hideProgress();
    }

    // ===== Popup edit atribut =====
    const popup = document.getElementById('popup');
    function showPopupAt(pixel) {
      popup.style.left = pixel[0] + 'px';
      popup.style.top = pixel[1] + 'px';
      popup.style.display = 'block';
    }
    function hidePopup() { popup.style.display = 'none'; }

    selectInteraction.on('select', e => {
      const feature = e.selected[0];
      if (!feature) { hidePopup(); return; }

      // Tentukan posisi popup
      let coord;
      try {
        const geom = feature.getGeometry();
        if (geom.getType() === 'Point') coord = geom.getCoordinates();
        else coord = ol.extent.getCenter(geom.getExtent());
      } catch { coord = map.getView().getCenter(); }
      const pixel = map.getPixelFromCoordinate(coord);

      // Build form
      const props = feature.getProperties();
      const missingSet = window._missingFieldsForPopup || new Set();
      const keys = Object.keys(props).filter(k => k !== 'geometry');

      let html = '<h4>Edit atribut</h4><form id="attrForm">';
      for (const key of keys) {
        const missingClass = missingSet.has(key) ? 'field-missing' : '';
        const val = (props[key] ?? '');
        html += `<div class="${missingClass}">
          <label>${key}</label>
          <input name="${key}" value="${String(val).replace(/"/g,'&quot;')}">
        </div>`;
      }
      html += '<div class="row-actions"><button type="button" class="btn" id="cancelEdit">Batal</button><button type="submit" class="btn">Simpan</button></div>';
      html += '</form>';
      popup.innerHTML = html;

      // Position and show
      showPopupAt(pixel);

      // Events
      document.getElementById('cancelEdit').onclick = () => hidePopup();
      document.getElementById('attrForm').onsubmit = ev => {
        ev.preventDefault();
        const formData = new FormData(ev.target);
        formData.forEach((val, key) => {
          feature.set(key, val);
        });
        // Re-apply type normalization for known fields
        const r = feature.get('remark');
        if (r !== undefined) feature.set('remark', String(r));
        // Trigger rerender
        vectorLayer.changed();
        hidePopup();
      };
    });

    // ===== Export buttons =====
    function exportFeatures(features, filename) {
      if (!features || features.length === 0) {
        pushNote({ title: 'Export', body: 'Tidak ada fitur untuk diexport.', type: 'error' });
        return;
      }
      const geo = new ol.format.GeoJSON().writeFeatures(features, {
        featureProjection: 'EPSG:3857',
        dataProjection: 'EPSG:4326' // export ke WGS84 umum
      });
      download(filename, geo);
      pushNote({ title: 'Export selesai', body: `${features.length} fitur diexport ke ${filename}`, type: 'success' });
    }

    document.getElementById('export-all').onclick = () => {
      if (!vectorLayer) return pushNote({ title: 'Export', body: 'Layer belum ada.', type: 'error' });
      const feats = vectorLayer.getSource().getFeatures();
      exportFeatures(feats, 'bulukumba_export.geojson');
    };
    document.getElementById('export-selected').onclick = () => {
      const feats = selectInteraction.getFeatures().getArray();
      exportFeatures(feats, 'bulukumba_selected.geojson');
    };

    // ===== Drag & Drop =====
    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => {
      e.preventDefault();
      for (const file of e.dataTransfer.files) {
        const name = file.name.toLowerCase();
        const reader = new FileReader();

        // GEOJSON
        if (name.endsWith('.geojson') || name.endsWith('.json')) {
          showProgress();
          reader.onprogress = evt => { if (evt.lengthComputable) updateProgress(Math.round((evt.loaded / evt.total) * 100)); };
          reader.onload = evt => {
            try {
              const txt = evt.target.result;
              geojsonData = JSON.parse(txt);
              if (!geojsonData || geojsonData.type !== 'FeatureCollection') {
                throw new Error('Bukan FeatureCollection');
              }
              detectedProjection = 'EPSG:4326';
              pushNote({ title: 'GeoJSON dimuat', body: `Fitur: ${geojsonData.features ? geojsonData.features.length : 0}`, type: 'success' });
              renderLayer();
            } catch (err) {
              pushNote({ title: 'GeoJSON tidak valid', body: String(err), type: 'error' });
              hideProgress();
            }
          };
          reader.onerror = () => { pushNote({ title: 'Gagal membaca GeoJSON', body: 'Periksa file dan coba lagi.', type: 'error' }); hideProgress(); };
          reader.readAsText(file);

        // SLD
        } else if (name.endsWith('.sld') || name.endsWith('.xml')) {
          showProgress();
          reader.onprogress = evt => { if (evt.lengthComputable) updateProgress(Math.round((evt.loaded / evt.total) * 100)); };
          reader.onload = evt => {
            try {
              sldText = evt.target.result;
              if (typeof SLDReader === 'undefined') {
                throw new Error('SLDReader tidak tersedia. Periksa pemuatan script ol-sld.');
              }
              const sldObjTest = SLDReader.Reader(sldText);
              const layers = Object.keys(sldObjTest.namedLayers || {});
              if (!layers.length) {
                pushNote({ title: 'SLD tanpa NamedLayer', body: 'Tambahkan <NamedLayer><Name>...</Name></NamedLayer>.', type: 'error' });
              } else {
                pushNote({ title: 'SLD dimuat', body: `NamedLayer: ${layers[0]}`, type: 'success' });
              }
              renderLayer();
            } catch (err) {
              pushNote({ title: 'SLD tidak valid', body: String(err), type: 'error' });
              hideProgress();
            }
          };
          reader.onerror = () => { pushNote({ title: 'Gagal membaca SLD', body: 'Periksa file SLD/XML Anda.', type: 'error' }); hideProgress(); };
          reader.readAsText(file);

        // SHP/ZIP
        } else if (name.endsWith('.zip') || name.endsWith('.shp')) {
          showProgress();
          shp(file).then(geojson => {
            if (!geojson || geojson.type !== 'FeatureCollection') {
              throw new Error('Shapefile tidak menghasilkan FeatureCollection');
            }
            geojsonData = geojson;
            detectedProjection = 'EPSG:4326'; // fallback; gunakan PRJ jika di-drop
            updateProgress(100);
            pushNote({ title: 'SHP/ZIP dimuat', body: `Fitur: ${geojsonData.features ? geojsonData.features.length : 0}`, type: 'success' });
            renderLayer();
          }).catch(err => {
            pushNote({ title: 'Gagal membaca SHP/ZIP', body: String(err), type: 'error' });
            hideProgress();
          });

        // PRJ
        } else if (name.endsWith('.prj')) {
          showProgress();
          reader.onload = evt => {
            try { detectEPSGFromPRJ(evt.target.result); }
            finally { hideProgress(); }
          };
          reader.onerror = () => { pushNote({ title: 'Gagal membaca PRJ', body: 'Periksa file .prj Anda.', type: 'error' }); hideProgress(); };
          reader.readAsText(file);

        } else {
          pushNote({ title: 'Tipe file tidak didukung', body: `File: ${file.name}`, type: 'error' });
        }
      }
    });
  </script>
</body>
</html>
